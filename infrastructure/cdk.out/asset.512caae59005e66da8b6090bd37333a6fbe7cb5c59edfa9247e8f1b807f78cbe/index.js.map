{
  "version": 3,
  "sources": ["../../lambda/websocket.ts"],
  "sourcesContent": ["/**\n * Lambda handler for WebSocket connections\n *\n * Routes:\n * - $connect - New WebSocket connection\n * - $disconnect - Connection closed\n * - $default - Fallback for unrouted messages\n * - subscribe - Subscribe to a session's updates\n */\n\nimport {\n    DynamoDBClient,\n    PutItemCommand,\n    DeleteItemCommand,\n    GetItemCommand,\n    QueryCommand,\n    UpdateItemCommand,\n} from \"@aws-sdk/client-dynamodb\"\nimport {\n    ApiGatewayManagementApiClient,\n    PostToConnectionCommand,\n} from \"@aws-sdk/client-apigatewaymanagementapi\"\nimport { marshall, unmarshall } from \"@aws-sdk/util-dynamodb\"\n\nconst dynamodb = new DynamoDBClient({})\nconst CONNECTIONS_TABLE = process.env.CONNECTIONS_TABLE!\nconst SESSIONS_TABLE = process.env.SESSIONS_TABLE!\n\ninterface WebSocketEvent {\n    requestContext: {\n        connectionId: string\n        routeKey: string\n        domainName: string\n        stage: string\n    }\n    body?: string\n}\n\ninterface WebSocketResult {\n    statusCode: number\n    body?: string\n}\n\n// Calculate TTL for connection cleanup (2 hours - connections auto-expire)\nconst calculateConnectionTtl = (): number => {\n    return Math.floor(Date.now() / 1000) + 7200 // 2 hours\n}\n\n// Get API Gateway Management client for sending messages\nconst getApiClient = (event: WebSocketEvent): ApiGatewayManagementApiClient => {\n    const { domainName, stage } = event.requestContext\n    return new ApiGatewayManagementApiClient({\n        endpoint: `https://${domainName}/${stage}`,\n    })\n}\n\n// Send a message to a specific connection\nconst sendToConnection = async (\n    client: ApiGatewayManagementApiClient,\n    connectionId: string,\n    data: any,\n): Promise<boolean> => {\n    try {\n        await client.send(\n            new PostToConnectionCommand({\n                ConnectionId: connectionId,\n                Data: Buffer.from(JSON.stringify(data)),\n            }),\n        )\n        return true\n    } catch (err: any) {\n        console.log(`Failed to send to ${connectionId}:`, err.message)\n        return false\n    }\n}\n\n// Handle new connection\nconst handleConnect = async (\n    event: WebSocketEvent,\n): Promise<WebSocketResult> => {\n    const connectionId = event.requestContext.connectionId\n    console.log(`New connection: ${connectionId}`)\n\n    try {\n        // Store connection (initially not subscribed to any session)\n        await dynamodb.send(\n            new PutItemCommand({\n                TableName: CONNECTIONS_TABLE,\n                Item: marshall({\n                    connectionId,\n                    sessionId: \"UNSUBSCRIBED\", // Placeholder until they subscribe\n                    connectedAt: Date.now(),\n                    ttl: calculateConnectionTtl(),\n                }),\n            }),\n        )\n\n        return { statusCode: 200 }\n    } catch (err) {\n        console.error(\"Error handling connect:\", err)\n        return { statusCode: 500 }\n    }\n}\n\n// Handle disconnection\nconst handleDisconnect = async (\n    event: WebSocketEvent,\n): Promise<WebSocketResult> => {\n    const connectionId = event.requestContext.connectionId\n    console.log(`Disconnected: ${connectionId}`)\n\n    try {\n        // Delete the connection record\n        await dynamodb.send(\n            new DeleteItemCommand({\n                TableName: CONNECTIONS_TABLE,\n                Key: marshall({ connectionId }),\n            }),\n        )\n\n        return { statusCode: 200 }\n    } catch (err) {\n        console.error(\"Error handling disconnect:\", err)\n        return { statusCode: 500 }\n    }\n}\n\n// Handle subscribe action - client wants to receive updates for a session\nconst handleSubscribe = async (\n    event: WebSocketEvent,\n): Promise<WebSocketResult> => {\n    const connectionId = event.requestContext.connectionId\n    const client = getApiClient(event)\n\n    try {\n        const body = JSON.parse(event.body || \"{}\")\n        const { sessionId } = body\n\n        if (!sessionId) {\n            await sendToConnection(client, connectionId, {\n                type: \"error\",\n                message: \"sessionId is required\",\n            })\n            return { statusCode: 400 }\n        }\n\n        // Verify session exists\n        const sessionResult = await dynamodb.send(\n            new GetItemCommand({\n                TableName: SESSIONS_TABLE,\n                Key: marshall({ id: sessionId }),\n            }),\n        )\n\n        if (!sessionResult.Item) {\n            await sendToConnection(client, connectionId, {\n                type: \"error\",\n                message: \"Session not found\",\n            })\n            return { statusCode: 404 }\n        }\n\n        const session = unmarshall(sessionResult.Item)\n\n        // Check if session is expired\n        if (session.ttl && session.ttl < Math.floor(Date.now() / 1000)) {\n            await sendToConnection(client, connectionId, {\n                type: \"error\",\n                message: \"Session has expired\",\n            })\n            return { statusCode: 410 }\n        }\n\n        // Update connection to subscribe to this session\n        await dynamodb.send(\n            new UpdateItemCommand({\n                TableName: CONNECTIONS_TABLE,\n                Key: marshall({ connectionId }),\n                UpdateExpression:\n                    \"SET sessionId = :sid, subscribedAt = :now, #ttl = :ttl\",\n                ExpressionAttributeNames: { \"#ttl\": \"ttl\" },\n                ExpressionAttributeValues: marshall({\n                    \":sid\": sessionId,\n                    \":now\": Date.now(),\n                    \":ttl\": calculateConnectionTtl(),\n                }),\n            }),\n        )\n\n        // Send current state to the newly subscribed client\n        await sendToConnection(client, connectionId, {\n            type: \"subscribed\",\n            sessionId,\n            combatState: session.combatState,\n            expiresAt: session.ttl\n                ? new Date(session.ttl * 1000).toISOString()\n                : null,\n        })\n\n        console.log(\n            `Connection ${connectionId} subscribed to session ${sessionId}`,\n        )\n        return { statusCode: 200 }\n    } catch (err) {\n        console.error(\"Error handling subscribe:\", err)\n        await sendToConnection(client, connectionId, {\n            type: \"error\",\n            message: \"Failed to subscribe\",\n        })\n        return { statusCode: 500 }\n    }\n}\n\n// Handle ping (for keeping connection alive)\nconst handlePing = async (event: WebSocketEvent): Promise<WebSocketResult> => {\n    const connectionId = event.requestContext.connectionId\n    const client = getApiClient(event)\n\n    // Extend connection TTL\n    try {\n        await dynamodb.send(\n            new UpdateItemCommand({\n                TableName: CONNECTIONS_TABLE,\n                Key: marshall({ connectionId }),\n                UpdateExpression: \"SET #ttl = :ttl, lastPing = :now\",\n                ExpressionAttributeNames: { \"#ttl\": \"ttl\" },\n                ExpressionAttributeValues: marshall({\n                    \":ttl\": calculateConnectionTtl(),\n                    \":now\": Date.now(),\n                }),\n            }),\n        )\n\n        await sendToConnection(client, connectionId, { type: \"pong\" })\n        return { statusCode: 200 }\n    } catch (err) {\n        console.error(\"Error handling ping:\", err)\n        return { statusCode: 500 }\n    }\n}\n\n// Handle unsubscribe action\nconst handleUnsubscribe = async (\n    event: WebSocketEvent,\n): Promise<WebSocketResult> => {\n    const connectionId = event.requestContext.connectionId\n    const client = getApiClient(event)\n\n    try {\n        await dynamodb.send(\n            new UpdateItemCommand({\n                TableName: CONNECTIONS_TABLE,\n                Key: marshall({ connectionId }),\n                UpdateExpression:\n                    \"SET sessionId = :unsub, unsubscribedAt = :now\",\n                ExpressionAttributeValues: marshall({\n                    \":unsub\": \"UNSUBSCRIBED\",\n                    \":now\": Date.now(),\n                }),\n            }),\n        )\n\n        await sendToConnection(client, connectionId, {\n            type: \"unsubscribed\",\n            message: \"Successfully unsubscribed from session\",\n        })\n\n        return { statusCode: 200 }\n    } catch (err) {\n        console.error(\"Error handling unsubscribe:\", err)\n        return { statusCode: 500 }\n    }\n}\n\n// Default handler for unrecognized routes\nconst handleDefault = async (\n    event: WebSocketEvent,\n): Promise<WebSocketResult> => {\n    const connectionId = event.requestContext.connectionId\n    const client = getApiClient(event)\n\n    console.log(`Default route for ${connectionId}:`, event.body)\n\n    try {\n        const body = JSON.parse(event.body || \"{}\")\n        const action = body.action\n\n        // Route based on action in body\n        switch (action) {\n            case \"subscribe\":\n                return handleSubscribe(event)\n            case \"unsubscribe\":\n                return handleUnsubscribe(event)\n            case \"ping\":\n                return handlePing(event)\n            default:\n                await sendToConnection(client, connectionId, {\n                    type: \"error\",\n                    message: `Unknown action: ${action}. Valid actions: subscribe, unsubscribe, ping`,\n                })\n                return { statusCode: 400 }\n        }\n    } catch (err) {\n        console.error(\"Error in default handler:\", err)\n        const client = getApiClient(event)\n        await sendToConnection(client, connectionId, {\n            type: \"error\",\n            message:\n                \"Invalid message format. Expected JSON with 'action' field.\",\n        })\n        return { statusCode: 400 }\n    }\n}\n\n// Main handler - route based on WebSocket routeKey\nexport const handler = async (\n    event: WebSocketEvent,\n): Promise<WebSocketResult> => {\n    console.log(\"Event:\", JSON.stringify(event, null, 2))\n\n    const routeKey = event.requestContext.routeKey\n\n    switch (routeKey) {\n        case \"$connect\":\n            return handleConnect(event)\n        case \"$disconnect\":\n            return handleDisconnect(event)\n        case \"subscribe\":\n            return handleSubscribe(event)\n        case \"unsubscribe\":\n            return handleUnsubscribe(event)\n        case \"ping\":\n            return handlePing(event)\n        case \"$default\":\n            return handleDefault(event)\n        default:\n            console.log(`Unknown route: ${routeKey}`)\n            return { statusCode: 400 }\n    }\n}\n"],
  "mappings": "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",
  "names": ["websocket_exports", "__export", "handler", "__toCommonJS", "import_client_dynamodb", "import_client_apigatewaymanagementapi", "import_util_dynamodb", "dynamodb", "CONNECTIONS_TABLE", "SESSIONS_TABLE", "calculateConnectionTtl", "getApiClient", "event", "domainName", "stage", "sendToConnection", "client", "connectionId", "data", "err", "handleConnect", "handleDisconnect", "handleSubscribe", "body", "sessionId", "sessionResult", "session", "handlePing", "handleUnsubscribe", "handleDefault", "action", "routeKey"]
}
