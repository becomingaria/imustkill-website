{
  "version": 3,
  "sources": ["../../lambda/sessions.ts"],
  "sourcesContent": ["/**\n * Lambda handler for Initiative Session CRUD operations\n *\n * Endpoints:\n * - POST /sessions - Create a new session\n * - GET /sessions/{sessionId} - Get session data\n * - PUT /sessions/{sessionId} - Update session data\n * - DELETE /sessions/{sessionId} - Delete/deactivate session\n */\n\nimport {\n    DynamoDBClient,\n    PutItemCommand,\n    GetItemCommand,\n    UpdateItemCommand,\n    DeleteItemCommand,\n    QueryCommand,\n} from \"@aws-sdk/client-dynamodb\"\nimport {\n    ApiGatewayManagementApiClient,\n    PostToConnectionCommand,\n} from \"@aws-sdk/client-apigatewaymanagementapi\"\nimport { marshall, unmarshall } from \"@aws-sdk/util-dynamodb\"\n\nconst dynamodb = new DynamoDBClient({})\nconst SESSIONS_TABLE = process.env.SESSIONS_TABLE!\nconst CONNECTIONS_TABLE = process.env.CONNECTIONS_TABLE!\nconst WEBSOCKET_ENDPOINT = process.env.WEBSOCKET_ENDPOINT\n\n// Initialize API Gateway Management client for sending WebSocket messages\nconst getApiGatewayClient = () => {\n    if (!WEBSOCKET_ENDPOINT) return null\n    return new ApiGatewayManagementApiClient({\n        endpoint: `https://${WEBSOCKET_ENDPOINT}`,\n    })\n}\n\ninterface APIGatewayProxyEvent {\n    httpMethod: string\n    path: string\n    pathParameters?: { sessionId?: string }\n    body?: string\n    requestContext: {\n        http: {\n            method: string\n            path: string\n        }\n    }\n}\n\ninterface APIGatewayProxyResult {\n    statusCode: number\n    headers: Record<string, string>\n    body: string\n}\n\n// CORS headers for all responses\nconst corsHeaders = {\n    \"Content-Type\": \"application/json\",\n    \"Access-Control-Allow-Origin\": \"*\",\n    \"Access-Control-Allow-Headers\": \"Content-Type,Authorization\",\n    \"Access-Control-Allow-Methods\": \"GET,POST,PUT,DELETE,OPTIONS\",\n}\n\n// Generate a unique session ID\nconst generateSessionId = (): string => {\n    return Date.now().toString(36) + Math.random().toString(36).substring(2, 7)\n}\n\n// Calculate TTL (DynamoDB will automatically delete expired items)\nconst calculateTtl = (expiresInMinutes: number): number => {\n    return Math.floor(Date.now() / 1000) + expiresInMinutes * 60\n}\n\n// Broadcast update to all WebSocket connections for a session\nconst broadcastToSession = async (sessionId: string, data: any) => {\n    const client = getApiGatewayClient()\n    if (!client) return\n\n    try {\n        // Get all connections for this session\n        const result = await dynamodb.send(\n            new QueryCommand({\n                TableName: CONNECTIONS_TABLE,\n                IndexName: \"session-connections\",\n                KeyConditionExpression: \"sessionId = :sid\",\n                ExpressionAttributeValues: marshall({ \":sid\": sessionId }),\n            }),\n        )\n\n        if (!result.Items?.length) return\n\n        const message = JSON.stringify({\n            type: \"session_update\",\n            data,\n        })\n\n        // Send to all connections (in parallel)\n        const sendPromises = result.Items.map(\n            async (item: Record<string, any>) => {\n                const connection = unmarshall(item)\n                try {\n                    await client.send(\n                        new PostToConnectionCommand({\n                            ConnectionId: connection.connectionId,\n                            Data: Buffer.from(message),\n                        }),\n                    )\n                } catch (err: any) {\n                    // Connection is stale, it will be cleaned up by TTL\n                    console.log(\n                        `Failed to send to ${connection.connectionId}:`,\n                        err.message,\n                    )\n                }\n            },\n        )\n\n        await Promise.all(sendPromises)\n    } catch (err) {\n        console.error(\"Error broadcasting to session:\", err)\n    }\n}\n\n// Handler functions for each operation\nconst createSession = async (body: string): Promise<APIGatewayProxyResult> => {\n    try {\n        const { combatState, expiresInMinutes = 480 } = JSON.parse(body) // Default 8 hours\n\n        const sessionId = generateSessionId()\n        const now = Date.now()\n        const ttl = calculateTtl(expiresInMinutes)\n\n        const item = {\n            id: sessionId,\n            combatState,\n            isActive: \"true\", // String for GSI\n            createdAt: now,\n            updatedAt: now,\n            ttl, // DynamoDB TTL - auto-cleanup!\n        }\n\n        await dynamodb.send(\n            new PutItemCommand({\n                TableName: SESSIONS_TABLE,\n                Item: marshall(item),\n            }),\n        )\n\n        return {\n            statusCode: 201,\n            headers: corsHeaders,\n            body: JSON.stringify({\n                sessionId,\n                expiresAt: new Date(ttl * 1000).toISOString(),\n                message: \"Session created successfully\",\n            }),\n        }\n    } catch (err) {\n        console.error(\"Error creating session:\", err)\n        return {\n            statusCode: 500,\n            headers: corsHeaders,\n            body: JSON.stringify({ error: \"Failed to create session\" }),\n        }\n    }\n}\n\nconst getSession = async (\n    sessionId: string,\n): Promise<APIGatewayProxyResult> => {\n    try {\n        const result = await dynamodb.send(\n            new GetItemCommand({\n                TableName: SESSIONS_TABLE,\n                Key: marshall({ id: sessionId }),\n            }),\n        )\n\n        if (!result.Item) {\n            return {\n                statusCode: 404,\n                headers: corsHeaders,\n                body: JSON.stringify({ error: \"Session not found\" }),\n            }\n        }\n\n        const session = unmarshall(result.Item)\n\n        // Check if TTL has passed (shouldn't happen often, but just in case)\n        if (session.ttl && session.ttl < Math.floor(Date.now() / 1000)) {\n            return {\n                statusCode: 404,\n                headers: corsHeaders,\n                body: JSON.stringify({ error: \"Session expired\" }),\n            }\n        }\n\n        return {\n            statusCode: 200,\n            headers: corsHeaders,\n            body: JSON.stringify({\n                sessionId: session.id,\n                combatState: session.combatState,\n                createdAt: session.createdAt,\n                updatedAt: session.updatedAt,\n                expiresAt: session.ttl\n                    ? new Date(session.ttl * 1000).toISOString()\n                    : null,\n            }),\n        }\n    } catch (err) {\n        console.error(\"Error getting session:\", err)\n        return {\n            statusCode: 500,\n            headers: corsHeaders,\n            body: JSON.stringify({ error: \"Failed to get session\" }),\n        }\n    }\n}\n\nconst updateSession = async (\n    sessionId: string,\n    body: string,\n): Promise<APIGatewayProxyResult> => {\n    try {\n        const { combatState, extendTtlMinutes } = JSON.parse(body)\n        const now = Date.now()\n\n        // Build update expression dynamically\n        let updateExpression = \"SET combatState = :cs, updatedAt = :now\"\n        const expressionValues: Record<string, any> = {\n            \":cs\": combatState,\n            \":now\": now,\n        }\n\n        // Optionally extend TTL\n        if (extendTtlMinutes) {\n            updateExpression += \", ttl = :ttl\"\n            expressionValues[\":ttl\"] = calculateTtl(extendTtlMinutes)\n        }\n\n        await dynamodb.send(\n            new UpdateItemCommand({\n                TableName: SESSIONS_TABLE,\n                Key: marshall({ id: sessionId }),\n                UpdateExpression: updateExpression,\n                ExpressionAttributeValues: marshall(expressionValues),\n                ConditionExpression: \"attribute_exists(id)\", // Ensure session exists\n            }),\n        )\n\n        // Broadcast update to all connected clients\n        await broadcastToSession(sessionId, combatState)\n\n        return {\n            statusCode: 200,\n            headers: corsHeaders,\n            body: JSON.stringify({\n                message: \"Session updated successfully\",\n                updatedAt: now,\n            }),\n        }\n    } catch (err: any) {\n        console.error(\"Error updating session:\", err)\n\n        if (err.name === \"ConditionalCheckFailedException\") {\n            return {\n                statusCode: 404,\n                headers: corsHeaders,\n                body: JSON.stringify({ error: \"Session not found\" }),\n            }\n        }\n\n        return {\n            statusCode: 500,\n            headers: corsHeaders,\n            body: JSON.stringify({ error: \"Failed to update session\" }),\n        }\n    }\n}\n\nconst deleteSession = async (\n    sessionId: string,\n): Promise<APIGatewayProxyResult> => {\n    try {\n        await dynamodb.send(\n            new DeleteItemCommand({\n                TableName: SESSIONS_TABLE,\n                Key: marshall({ id: sessionId }),\n            }),\n        )\n\n        // Notify all connected clients that session is closed\n        const client = getApiGatewayClient()\n        if (client) {\n            const connectionsResult = await dynamodb.send(\n                new QueryCommand({\n                    TableName: CONNECTIONS_TABLE,\n                    IndexName: \"session-connections\",\n                    KeyConditionExpression: \"sessionId = :sid\",\n                    ExpressionAttributeValues: marshall({ \":sid\": sessionId }),\n                }),\n            )\n\n            if (connectionsResult.Items?.length) {\n                const message = JSON.stringify({\n                    type: \"session_closed\",\n                    message: \"Session has been ended by the host\",\n                })\n\n                await Promise.all(\n                    connectionsResult.Items.map(\n                        async (item: Record<string, any>) => {\n                            const conn = unmarshall(item)\n                            try {\n                                await client.send(\n                                    new PostToConnectionCommand({\n                                        ConnectionId: conn.connectionId,\n                                        Data: Buffer.from(message),\n                                    }),\n                                )\n                            } catch {\n                                // Ignore stale connections\n                            }\n                        },\n                    ),\n                )\n            }\n        }\n\n        return {\n            statusCode: 200,\n            headers: corsHeaders,\n            body: JSON.stringify({ message: \"Session deleted successfully\" }),\n        }\n    } catch (err) {\n        console.error(\"Error deleting session:\", err)\n        return {\n            statusCode: 500,\n            headers: corsHeaders,\n            body: JSON.stringify({ error: \"Failed to delete session\" }),\n        }\n    }\n}\n\n// Main handler\nexport const handler = async (\n    event: APIGatewayProxyEvent,\n): Promise<APIGatewayProxyResult> => {\n    console.log(\"Event:\", JSON.stringify(event, null, 2))\n\n    const method = event.requestContext?.http?.method || event.httpMethod\n    const path = event.requestContext?.http?.path || event.path\n    const sessionId = event.pathParameters?.sessionId\n\n    // Handle OPTIONS for CORS preflight\n    if (method === \"OPTIONS\") {\n        return {\n            statusCode: 200,\n            headers: corsHeaders,\n            body: \"\",\n        }\n    }\n\n    // Route to appropriate handler\n    if (path === \"/sessions\" && method === \"POST\") {\n        return createSession(event.body || \"{}\")\n    }\n\n    if (path.startsWith(\"/sessions/\") && sessionId) {\n        switch (method) {\n            case \"GET\":\n                return getSession(sessionId)\n            case \"PUT\":\n                return updateSession(sessionId, event.body || \"{}\")\n            case \"DELETE\":\n                return deleteSession(sessionId)\n        }\n    }\n\n    return {\n        statusCode: 404,\n        headers: corsHeaders,\n        body: JSON.stringify({ error: \"Not found\" }),\n    }\n}\n"],
  "mappings": "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",
  "names": ["sessions_exports", "__export", "handler", "__toCommonJS", "import_client_dynamodb", "import_client_apigatewaymanagementapi", "import_util_dynamodb", "dynamodb", "SESSIONS_TABLE", "CONNECTIONS_TABLE", "WEBSOCKET_ENDPOINT", "getApiGatewayClient", "corsHeaders", "generateSessionId", "calculateTtl", "expiresInMinutes", "broadcastToSession", "sessionId", "data", "client", "result", "message", "sendPromises", "item", "connection", "err", "createSession", "body", "combatState", "now", "ttl", "getSession", "session", "updateSession", "extendTtlMinutes", "updateExpression", "expressionValues", "deleteSession", "connectionsResult", "conn", "event", "method", "path"]
}
